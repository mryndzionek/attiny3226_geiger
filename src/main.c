#include <avr/interrupt.h>
#include <avr/io.h>
#include <avr/power.h>
#include <avr/sleep.h>
#include <avr/wdt.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <u8g2.h>
#include <u8x8_tinyavr_2.h>
#include <util/atomic.h>
#include <util/delay.h>

#include "config.h"

#define DISPLAY_I2C_ADDR (0x78)

#define GREEN_LED_PIN PIN3_bm     // PA3
#define RED_LED_PIN PIN2_bm       // PA2
#define BUTTON_PIN PIN1_bm        // PA1
#define HV_BOOST_PWM_PIN PIN3_bm  // PB3
#define COMP_INPUT_PIN PIN7_bm    // PA7
#define GEIGER_PULSE_PIN PIN2_bm  // PB2
#define BUZZER_PULSE_PIN PIN0_bm  // PC0

#define DACREF_VALUE \
  (880UL * 256 / 1024)  // should be 950 (for 380V tube voltage), lower due to
                        // some inaccuracies

#define DOSE_CALC_TIMEOUT_S (5U)
#define DOSE_CALC_TIMEOUT_TICKS (DOSE_CALC_TIMEOUT_S * 1024U)
#define CPM_BUF_SIZE (60U / DOSE_CALC_TIMEOUT_S)

#define BUTTON_DEBOUNCE_COUNT (20)

#define LED_PULSE_TICKS (15U)

#define ORANGE_THRESHOLD (50)  // 0.5 µS/h
#define RED_THRESHOLD (1000)   // 10 µS/h

#define ORANGE_THRESHOLD_ANGLE (80)
#define RED_THRESHOLD_ANGLE (54)
#define MAX_RATE_THRESHOLD_ANGLE (14)

#define DISPLAY_TIMEOUT_COUNT (60U / DOSE_CALC_TIMEOUT_S)

#define BATTERY_LEVEL_NUM (4)
#define NUM_BATTERIES (3)

#define RATE_HISTORY_LEN (10U * 60 / DOSE_CALC_TIMEOUT_S)  // last 10 minutes

#define BIG_LABEL_FONT (u8g2_font_profont15_tf)
#define MEDIUM_LABEL_FONT (u8g2_font_5x7_mr)
#define SMALL_LABEL_FONT (u8g2_font_5x7_mr)

#define DIGITS_Y_POS (54)

#define LOG_EXT_IDX (449)
#define LOG_LUT_LEN (473)

#define EV_DOSE_CALC_TIMEOUT _BV(0)
#define EV_BUTTON_SHORT_PRESS _BV(1)
#define EV_BUTTON_LONG_PRESS _BV(2)

#define g_events (GPIOR0)
#define events (GPIOR1)

typedef struct {
  bool state;
  uint8_t pulse_timer;
} led_state_t;

typedef struct {
  bool state;
} buzzer_state_t;

typedef struct {
  bool pressed;
  uint8_t deb_count;
  uint16_t press_count;
} button_state_t;

typedef enum {
  alarm_level_green = 0,
  alarm_level_orange,
  alarm_level_red,
} alarm_level_e;

typedef enum {
  display_power_save = 0,
  display_rate,
  display_rate_analog,
  display_cpm,
  display_dose,
  display_rate_history,
  display_state_loop,
  display_state_info,
} display_state_e;

typedef struct {
  uint8_t state;
  uint8_t timeout;
  uint32_t cpm;
  uint32_t rate;
  uint32_t dose;  // in 0.01 µSv
  uint8_t alarm_level;
  uint16_t vdd;
  uint8_t bat_level;
  int16_t temp;
  uint32_t rate_history[RATE_HISTORY_LEN];  // last 10 minutes
  uint16_t rate_history_idx;
  uint32_t uptime_counter;
  uint16_t reset_counter;
} display_ctx_t;

// Alkaline
static const uint16_t battery_level_thresholds[BATTERY_LEVEL_NUM] = {116, 122,
                                                                     128, 136};

#define warning_width (13)
#define warning_height (14)
static const unsigned char warning_bits[] = {
    0x40, 0x00, 0xa0, 0x00, 0xa0, 0x00, 0x10, 0x01, 0x10, 0x01,
    0x48, 0x02, 0x48, 0x02, 0x44, 0x04, 0x44, 0x04, 0x42, 0x08,
    0x02, 0x08, 0x41, 0x10, 0x01, 0x10, 0xff, 0x1f};

const uint8_t icons_font[249] U8G2_FONT_SECTION("icons_font") =
    "\7\0\4\3\5\5\3\5\6\25\24\0\4\22\0\22\0\0\0\0\0\0\334\60\24\20Y\313q`\22\35"
    "\21\35\21\275:\42:\344\300\4\0\61\30\20Y\313q`\22\35\21!\32\21!:!:!"
    "\32\21\35"
    "r`\2\62\31\20Y\313q`\22\35\21\241.\42B\335\204\272\11u\21\321!\7&"
    "\0\63\31\20Y"
    "\313q`\22\35\21\241QD\204F\23\32Mh\24\21\35r`\2\64\30\20Y\313q`"
    "\22\35\21\241"
    "\213\24\272\230\320\305\204.R\207\34\230\0\65=\224\226\326g,&(*"
    "\25\22\30\22\24\61\66\21\23"
    "AF\21\22QT\221\302\310B\302\310B\242D\244B\216NP=LD\30YH\224UL\220Q\232"
    "\203\230(\21\23A\61a;\0\66'\22\362\312Gm{\20z\20z\20z\20)\23\42\30\24} "
    "\24\64\62cq@\26\63\35\17b)B\42\64:\1\0\0\0\4\377\377\0";

const uint8_t main_font[652] U8G2_FONT_SECTION("main_font") =
    "\14\1\5\4\5\6\1\2\6\22%\2\376#\367#\0\0\0\0\0\2o,"
    "\17\255L\373\341\377\225\221"
    "\12*i,\251\0.\16\255L\373\341\377\225\221\12*i|"
    "\0\60P\267\314\235\312S\214)\227\336)"
    "\246\234\312\20TJI\244\224DJI\244\224DJI\244\224DJI\244\224DJI\244\224DJI"
    "\244\224DJI\244\224DJI\244\224DJI\244\224DJI\304\20T\14A\305T\350!\247\30S"
    "\317|\200\1\61\26\267\314\315\310$\262\212\346!\227sC\220I\377\377\377>"
    "\260\0\62;\267\314\235\12"
    "L\214)\227\214\70\247\230r*CP\61$\21C\22\61\4\25CP\211%\232X\311\22+Yb\211"
    "&V\321\304J\226X\311\42\37\20\346\1a\36\20\346\1\361\201\4\63\63\267\314="
    "\36\20\346\1a\36"
    "\20\346\1!K,\321\304*\232XE\23\213<\20\275\344\224,"
    "\263\310\62\351\223\5\11TLu\216\70"
    "\310)\306\324\63\37`\0\64\67\267\314\215\212,\222L\42+I&\221\225$"
    "\223\310J\222Id%\10"
    "#\243,\62\212*\243\250\62\212\42\244(BJz`\224\7Fy`\224\7\206+\262\276\17,"
    "\0\65"
    ":\267\314-\36\30\345\201Q\36\30\345\201Q\212\254\237("
    "\313\245\207\36\10\347\1aN)\306\234R\12"
    "*\245$\62\351\63$\21CP\61\345\24S!#"
    "\16r\212\61\365\314\7\30\0\66H\267\314\215\314S"
    "\214)\227\336)\246\34\202\212!\250\224\222H)"
    "\262N\224\345\322C\17\204\363\200\60\306\24cN)\5"
    "\225R\22)%\221R\22)%\221R\22)\5\25CP\61\4\25S!#\16r\212\61\365\314\7\30"
    "\0\67\63\267\314-\36\30\345\201Q\36\30\345\201Q\12*\245\240R\312)"
    "\246\234b\312)\262\304\42k"
    "\261\310*\232Xd\25\213\254\305\42k\261\310Z,\262|"
    "\240\1\70I\267\314\235\312S\214)\227\336)"
    "\246\234\312\20T\14I\304\220D\14I\304\220D\14A\305\224S\214)\5\275\324\24["
    "-\275cJ\71"
    "\225!\250\30\222\210!\211\30\222\210!\211\30\202\212)\247\230\12="
    "\344\24c\352\231\17\60\0\71G\267"
    "\314\235\312S\214)\227\336)"
    "\246\234\312\20TJI\244\224DJI\244\224DJI\304\220D\14A\305"
    "\224SL\61\346<\20\316\3\1\275\344X\21d\322\31\222\210!"
    "\250\230r\212\251\220\21\7\71\305\230z"
    "\346\3\14\0\0\0\0\4\377\377\0";

static const uint16_t logx[LOG_LUT_LEN] = {
    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008,
    0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F, 0x0010, 0x0011,
    0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001A,
    0x001B, 0x001C, 0x001D, 0x001E, 0x001F, 0x0020, 0x0021, 0x0022, 0x0023,
    0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C,
    0x002D, 0x002E, 0x002F, 0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035,
    0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003F,
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0046, 0x0047, 0x0048, 0x0049,
    0x004B, 0x004C, 0x004E, 0x004F, 0x0050, 0x0052, 0x0053, 0x0055, 0x0056,
    0x0058, 0x0059, 0x005B, 0x005D, 0x005E, 0x0060, 0x0062, 0x0064, 0x0065,
    0x0067, 0x0069, 0x006B, 0x006D, 0x006F, 0x0071, 0x0073, 0x0075, 0x0077,
    0x0079, 0x007B, 0x007E, 0x0080, 0x0082, 0x0085, 0x0087, 0x0089, 0x008C,
    0x008F, 0x0091, 0x0094, 0x0096, 0x0099, 0x009C, 0x009F, 0x00A2, 0x00A4,
    0x00A7, 0x00AB, 0x00AE, 0x00B1, 0x00B4, 0x00B7, 0x00BB, 0x00BE, 0x00C1,
    0x00C5, 0x00C8, 0x00CC, 0x00D0, 0x00D3, 0x00D7, 0x00DB, 0x00DF, 0x00E3,
    0x00E7, 0x00EC, 0x00F0, 0x00F4, 0x00F9, 0x00FD, 0x0102, 0x0106, 0x010B,
    0x0110, 0x0115, 0x011A, 0x011F, 0x0124, 0x0129, 0x012F, 0x0134, 0x013A,
    0x0140, 0x0145, 0x014B, 0x0151, 0x0157, 0x015E, 0x0164, 0x016A, 0x0171,
    0x0178, 0x017E, 0x0185, 0x018C, 0x0194, 0x019B, 0x01A2, 0x01AA, 0x01B2,
    0x01BA, 0x01C2, 0x01CA, 0x01D2, 0x01DB, 0x01E3, 0x01EC, 0x01F5, 0x01FE,
    0x0207, 0x0211, 0x021A, 0x0224, 0x022E, 0x0238, 0x0242, 0x024D, 0x0257,
    0x0262, 0x026D, 0x0279, 0x0284, 0x0290, 0x029C, 0x02A8, 0x02B4, 0x02C1,
    0x02CD, 0x02DA, 0x02E8, 0x02F5, 0x0303, 0x0311, 0x031F, 0x032E, 0x033C,
    0x034B, 0x035B, 0x036A, 0x037A, 0x038A, 0x039B, 0x03AB, 0x03BD, 0x03CE,
    0x03E0, 0x03F2, 0x0404, 0x0416, 0x0429, 0x043D, 0x0450, 0x0465, 0x0479,
    0x048E, 0x04A3, 0x04B8, 0x04CE, 0x04E5, 0x04FB, 0x0513, 0x052A, 0x0542,
    0x055A, 0x0573, 0x058D, 0x05A6, 0x05C1, 0x05DB, 0x05F7, 0x0612, 0x062F,
    0x064B, 0x0668, 0x0686, 0x06A5, 0x06C3, 0x06E3, 0x0703, 0x0723, 0x0745,
    0x0766, 0x0789, 0x07AC, 0x07CF, 0x07F4, 0x0819, 0x083E, 0x0864, 0x088B,
    0x08B3, 0x08DC, 0x0905, 0x092F, 0x0959, 0x0985, 0x09B1, 0x09DE, 0x0A0C,
    0x0A3A, 0x0A6A, 0x0A9A, 0x0ACC, 0x0AFE, 0x0B31, 0x0B65, 0x0B9A, 0x0BD0,
    0x0C07, 0x0C3E, 0x0C77, 0x0CB1, 0x0CEC, 0x0D28, 0x0D65, 0x0DA4, 0x0DE3,
    0x0E24, 0x0E65, 0x0EA8, 0x0EEC, 0x0F32, 0x0F78, 0x0FC0, 0x1009, 0x1054,
    0x10A0, 0x10ED, 0x113B, 0x118C, 0x11DD, 0x1230, 0x1285, 0x12DB, 0x1332,
    0x138B, 0x13E6, 0x1443, 0x14A1, 0x1501, 0x1562, 0x15C6, 0x162B, 0x1692,
    0x16FB, 0x1765, 0x17D2, 0x1841, 0x18B1, 0x1924, 0x1999, 0x1A10, 0x1A89,
    0x1B04, 0x1B82, 0x1C02, 0x1C84, 0x1D08, 0x1D8F, 0x1E19, 0x1EA4, 0x1F33,
    0x1FC4, 0x2057, 0x20EE, 0x2187, 0x2222, 0x22C1, 0x2362, 0x2407, 0x24AE,
    0x2559, 0x2606, 0x26B7, 0x276B, 0x2822, 0x28DC, 0x299A, 0x2A5C, 0x2B20,
    0x2BE9, 0x2CB5, 0x2D85, 0x2E58, 0x2F30, 0x300B, 0x30EA, 0x31CD, 0x32B5,
    0x33A0, 0x3490, 0x3584, 0x367D, 0x377A, 0x387C, 0x3983, 0x3A8E, 0x3B9E,
    0x3CB3, 0x3DCD, 0x3EEC, 0x4010, 0x413A, 0x4269, 0x439E, 0x44D8, 0x4618,
    0x475E, 0x48A9, 0x49FB, 0x4B53, 0x4CB1, 0x4E15, 0x4F80, 0x50F1, 0x5269,
    0x53E8, 0x556E, 0x56FB, 0x588F, 0x5A2B, 0x5BCE, 0x5D78, 0x5F2B, 0x60E5,
    0x62A7, 0x6472, 0x6644, 0x6820, 0x6A03, 0x6BF0, 0x6DE6, 0x6FE4, 0x71EC,
    0x73FE, 0x7619, 0x783D, 0x7A6C, 0x7CA5, 0x7EE8, 0x8136, 0x838E, 0x85F2,
    0x8860, 0x8ADA, 0x8D5F, 0x8FF0, 0x928D, 0x9536, 0x97EB, 0x9AAD, 0x9D7C,
    0xA057, 0xA341, 0xA637, 0xA93C, 0xAC4E, 0xAF6F, 0xB29E, 0xB5DC, 0xB929,
    0xBC85, 0xBFF1, 0xC36D, 0xC6F9, 0xCA96, 0xCE43, 0xD202, 0xD5D2, 0xD9B3,
    0xDDA7, 0xE1AD, 0xE5C5, 0xE9F1, 0xEE30, 0xF283, 0xF6EA, 0xFB65, 0xFFF5,
    0x049B, 0x0956, 0x0E27, 0x130E, 0x180C, 0x1D22, 0x224E, 0x2793, 0x2CF1,
    0x3267, 0x37F7, 0x3DA1, 0x4365, 0x4944, 0x4F3E, 0x5553, 0x5B85, 0x61D4,
    0x6840, 0x6ECA, 0x7573, 0x7C3A, 0x8321,
};

static const uint16_t logy[LOG_LUT_LEN] = {
    0x0000, 0x0000, 0x0027, 0x003D, 0x004D, 0x0059, 0x0064, 0x006C, 0x0074,
    0x007A, 0x0080, 0x0085, 0x008A, 0x008F, 0x0093, 0x0097, 0x009A, 0x009D,
    0x00A1, 0x00A4, 0x00A7, 0x00A9, 0x00AC, 0x00AE, 0x00B1, 0x00B3, 0x00B5,
    0x00B7, 0x00B9, 0x00BB, 0x00BD, 0x00BF, 0x00C1, 0x00C2, 0x00C4, 0x00C6,
    0x00C7, 0x00C9, 0x00CA, 0x00CC, 0x00CD, 0x00CE, 0x00D0, 0x00D1, 0x00D2,
    0x00D4, 0x00D5, 0x00D6, 0x00D7, 0x00D8, 0x00D9, 0x00DB, 0x00DC, 0x00DD,
    0x00DE, 0x00DF, 0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6,
    0x00E7, 0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF,
    0x00F0, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7, 0x00F8,
    0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF, 0x0100, 0x0101,
    0x0102, 0x0103, 0x0104, 0x0105, 0x0106, 0x0107, 0x0108, 0x0109, 0x010A,
    0x010B, 0x010C, 0x010D, 0x010E, 0x010F, 0x0110, 0x0111, 0x0112, 0x0113,
    0x0114, 0x0115, 0x0116, 0x0117, 0x0118, 0x0119, 0x011A, 0x011B, 0x011C,
    0x011D, 0x011E, 0x011F, 0x0120, 0x0121, 0x0122, 0x0123, 0x0124, 0x0125,
    0x0126, 0x0127, 0x0128, 0x0129, 0x012A, 0x012B, 0x012C, 0x012D, 0x012E,
    0x012F, 0x0130, 0x0131, 0x0132, 0x0133, 0x0134, 0x0135, 0x0136, 0x0137,
    0x0138, 0x0139, 0x013A, 0x013B, 0x013C, 0x013D, 0x013E, 0x013F, 0x0140,
    0x0141, 0x0142, 0x0143, 0x0144, 0x0145, 0x0146, 0x0147, 0x0148, 0x0149,
    0x014A, 0x014B, 0x014C, 0x014D, 0x014E, 0x014F, 0x0150, 0x0151, 0x0152,
    0x0153, 0x0154, 0x0155, 0x0156, 0x0157, 0x0158, 0x0159, 0x015A, 0x015B,
    0x015C, 0x015D, 0x015E, 0x015F, 0x0160, 0x0161, 0x0162, 0x0163, 0x0164,
    0x0165, 0x0166, 0x0167, 0x0168, 0x0169, 0x016A, 0x016B, 0x016C, 0x016D,
    0x016E, 0x016F, 0x0170, 0x0171, 0x0172, 0x0173, 0x0174, 0x0175, 0x0176,
    0x0177, 0x0178, 0x0179, 0x017A, 0x017B, 0x017C, 0x017D, 0x017E, 0x017F,
    0x0180, 0x0181, 0x0182, 0x0183, 0x0184, 0x0185, 0x0186, 0x0187, 0x0188,
    0x0189, 0x018A, 0x018B, 0x018C, 0x018D, 0x018E, 0x018F, 0x0190, 0x0191,
    0x0192, 0x0193, 0x0194, 0x0195, 0x0196, 0x0197, 0x0198, 0x0199, 0x019A,
    0x019B, 0x019C, 0x019D, 0x019E, 0x019F, 0x01A0, 0x01A1, 0x01A2, 0x01A3,
    0x01A4, 0x01A5, 0x01A6, 0x01A7, 0x01A8, 0x01A9, 0x01AA, 0x01AB, 0x01AC,
    0x01AD, 0x01AE, 0x01AF, 0x01B0, 0x01B1, 0x01B2, 0x01B3, 0x01B4, 0x01B5,
    0x01B6, 0x01B7, 0x01B8, 0x01B9, 0x01BA, 0x01BB, 0x01BC, 0x01BD, 0x01BE,
    0x01BF, 0x01C0, 0x01C1, 0x01C2, 0x01C3, 0x01C4, 0x01C5, 0x01C6, 0x01C7,
    0x01C8, 0x01C9, 0x01CA, 0x01CB, 0x01CC, 0x01CD, 0x01CE, 0x01CF, 0x01D0,
    0x01D1, 0x01D2, 0x01D3, 0x01D4, 0x01D5, 0x01D6, 0x01D7, 0x01D8, 0x01D9,
    0x01DA, 0x01DB, 0x01DC, 0x01DD, 0x01DE, 0x01DF, 0x01E0, 0x01E1, 0x01E2,
    0x01E3, 0x01E4, 0x01E5, 0x01E6, 0x01E7, 0x01E8, 0x01E9, 0x01EA, 0x01EB,
    0x01EC, 0x01ED, 0x01EE, 0x01EF, 0x01F0, 0x01F1, 0x01F2, 0x01F3, 0x01F4,
    0x01F5, 0x01F6, 0x01F7, 0x01F8, 0x01F9, 0x01FA, 0x01FB, 0x01FC, 0x01FD,
    0x01FE, 0x01FF, 0x0200, 0x0201, 0x0202, 0x0203, 0x0204, 0x0205, 0x0206,
    0x0207, 0x0208, 0x0209, 0x020A, 0x020B, 0x020C, 0x020D, 0x020E, 0x020F,
    0x0210, 0x0211, 0x0212, 0x0213, 0x0214, 0x0215, 0x0216, 0x0217, 0x0218,
    0x0219, 0x021A, 0x021B, 0x021C, 0x021D, 0x021E, 0x021F, 0x0220, 0x0221,
    0x0222, 0x0223, 0x0224, 0x0225, 0x0226, 0x0227, 0x0228, 0x0229, 0x022A,
    0x022B, 0x022C, 0x022D, 0x022E, 0x022F, 0x0230, 0x0231, 0x0232, 0x0233,
    0x0234, 0x0235, 0x0236, 0x0237, 0x0238, 0x0239, 0x023A, 0x023B, 0x023C,
    0x023D, 0x023E, 0x023F, 0x0240, 0x0241, 0x0242, 0x0243, 0x0244, 0x0245,
    0x0246, 0x0247, 0x0248, 0x0249, 0x024A, 0x024B, 0x024C, 0x024D, 0x024E,
    0x024F, 0x0250, 0x0251, 0x0252, 0x0253, 0x0254, 0x0255, 0x0256, 0x0257,
    0x0258, 0x0259, 0x025A, 0x025B, 0x025C, 0x025D, 0x025E, 0x025F, 0x0260,
    0x0261, 0x0262, 0x0263, 0x0264, 0x0265, 0x0266, 0x0267, 0x0268, 0x0269,
    0x026A, 0x026B, 0x026C, 0x026D, 0x026E, 0x026F, 0x0270, 0x0271, 0x0272,
    0x0273, 0x0274, 0x0275, 0x0276, 0x0277, 0x0278, 0x0279, 0x027A, 0x027B,
    0x027C, 0x027D, 0x027E, 0x027F, 0x0280,
};

static const uint8_t needle1_x[LOG_LUT_LEN] = {
    0x28, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2C, 0x2D, 0x2D, 0x2E, 0x2E, 0x2F,
    0x2F, 0x2F, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x32, 0x32,
    0x32, 0x32, 0x32, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x34, 0x34,
    0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
    0x35, 0x35, 0x35, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37,
    0x37, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38,
    0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x3A, 0x3A,
    0x3A, 0x3A, 0x3A, 0x3A, 0x3A, 0x3A, 0x3A, 0x3A, 0x3A, 0x3B, 0x3B, 0x3B,
    0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3C, 0x3C, 0x3C, 0x3C,
    0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D,
    0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E,
    0x3E, 0x3E, 0x3E, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
    0x3F, 0x3F, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x42,
    0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x43, 0x43, 0x43,
    0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x44, 0x44, 0x44, 0x44,
    0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x45, 0x45, 0x45, 0x45, 0x45,
    0x45, 0x45, 0x45, 0x45, 0x45, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46,
    0x46, 0x46, 0x46, 0x46, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47,
    0x47, 0x47, 0x47, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
    0x48, 0x48, 0x48, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
    0x49, 0x49, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A,
    0x4A, 0x4A, 0x4B, 0x4B, 0x4B, 0x4B, 0x4B, 0x4B, 0x4B, 0x4B, 0x4B, 0x4B,
    0x4B, 0x4B, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C,
    0x4C, 0x4C, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D,
    0x4D, 0x4D, 0x4D, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E,
    0x4E, 0x4E, 0x4E, 0x4E, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F,
    0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50,
    0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x51, 0x51, 0x51, 0x51,
    0x51, 0x51, 0x51, 0x51, 0x51, 0x51, 0x51, 0x51, 0x51, 0x51, 0x51, 0x52,
    0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52,
    0x52, 0x52, 0x52, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53,
    0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x54, 0x54, 0x54, 0x54,
    0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54,
    0x54, 0x54, 0x54, 0x54, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56,
    0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56,
    0x56, 0x56, 0x56, 0x56, 0x56,
};

static const uint8_t needle1_y[LOG_LUT_LEN] = {
    0x3B, 0x3B, 0x38, 0x36, 0x35, 0x34, 0x33, 0x33, 0x32, 0x32, 0x31, 0x31,
    0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F,
    0x2F, 0x2F, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
    0x2E, 0x2E, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D,
    0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D,
    0x2D, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
    0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
    0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
    0x2C, 0x2C, 0x2C, 0x2C, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B,
    0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B,
    0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B,
    0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B,
    0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B,
    0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B,
    0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B,
    0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B,
    0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B,
    0x2B, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
    0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
    0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
    0x2C, 0x2C, 0x2C, 0x2C, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D,
    0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D,
    0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
    0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
    0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F,
    0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F,
    0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
    0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x32, 0x32,
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
    0x32, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
    0x33, 0x33, 0x33, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34,
    0x34, 0x34, 0x34, 0x34, 0x34, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
    0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x37, 0x37, 0x37, 0x37,
    0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x38, 0x38, 0x38, 0x38, 0x38,
    0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x39, 0x39, 0x39, 0x39, 0x39,
    0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x3A, 0x3A, 0x3A, 0x3A, 0x3A, 0x3A,
    0x3A, 0x3A, 0x3A, 0x3A, 0x3A, 0x3A, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B,
    0x3B, 0x3B, 0x3B, 0x3B, 0x3B,
};

static const uint8_t needle2_x[LOG_LUT_LEN] = {
    0x05, 0x05, 0x09, 0x0B, 0x0D, 0x0F, 0x11, 0x12, 0x13, 0x14, 0x16, 0x16,
    0x17, 0x18, 0x19, 0x1A, 0x1A, 0x1B, 0x1C, 0x1C, 0x1D, 0x1D, 0x1E, 0x1E,
    0x1F, 0x1F, 0x20, 0x20, 0x20, 0x21, 0x21, 0x22, 0x22, 0x22, 0x23, 0x23,
    0x23, 0x24, 0x24, 0x24, 0x25, 0x25, 0x25, 0x26, 0x26, 0x26, 0x26, 0x27,
    0x27, 0x27, 0x27, 0x28, 0x28, 0x28, 0x28, 0x29, 0x29, 0x29, 0x29, 0x29,
    0x2A, 0x2A, 0x2A, 0x2A, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2C, 0x2C, 0x2C,
    0x2C, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2E, 0x2E, 0x2E, 0x2E, 0x2F, 0x2F,
    0x2F, 0x2F, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x32,
    0x32, 0x32, 0x32, 0x33, 0x33, 0x33, 0x33, 0x33, 0x34, 0x34, 0x34, 0x34,
    0x35, 0x35, 0x35, 0x35, 0x36, 0x36, 0x36, 0x36, 0x37, 0x37, 0x37, 0x37,
    0x37, 0x38, 0x38, 0x38, 0x38, 0x39, 0x39, 0x39, 0x39, 0x3A, 0x3A, 0x3A,
    0x3A, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3C, 0x3C, 0x3C, 0x3C, 0x3D, 0x3D,
    0x3D, 0x3D, 0x3E, 0x3E, 0x3E, 0x3E, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x40,
    0x40, 0x40, 0x40, 0x41, 0x41, 0x41, 0x41, 0x42, 0x42, 0x42, 0x42, 0x43,
    0x43, 0x43, 0x43, 0x43, 0x44, 0x44, 0x44, 0x44, 0x45, 0x45, 0x45, 0x45,
    0x46, 0x46, 0x46, 0x46, 0x47, 0x47, 0x47, 0x47, 0x47, 0x48, 0x48, 0x48,
    0x48, 0x49, 0x49, 0x49, 0x49, 0x4A, 0x4A, 0x4A, 0x4A, 0x4B, 0x4B, 0x4B,
    0x4B, 0x4B, 0x4C, 0x4C, 0x4C, 0x4C, 0x4D, 0x4D, 0x4D, 0x4D, 0x4E, 0x4E,
    0x4E, 0x4E, 0x4E, 0x4F, 0x4F, 0x4F, 0x4F, 0x50, 0x50, 0x50, 0x50, 0x51,
    0x51, 0x51, 0x51, 0x51, 0x52, 0x52, 0x52, 0x52, 0x53, 0x53, 0x53, 0x53,
    0x53, 0x54, 0x54, 0x54, 0x54, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0x56,
    0x56, 0x56, 0x57, 0x57, 0x57, 0x57, 0x57, 0x58, 0x58, 0x58, 0x58, 0x58,
    0x59, 0x59, 0x59, 0x59, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5B, 0x5B, 0x5B,
    0x5B, 0x5B, 0x5C, 0x5C, 0x5C, 0x5C, 0x5D, 0x5D, 0x5D, 0x5D, 0x5D, 0x5E,
    0x5E, 0x5E, 0x5E, 0x5E, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x60, 0x60, 0x60,
    0x60, 0x60, 0x61, 0x61, 0x61, 0x61, 0x61, 0x62, 0x62, 0x62, 0x62, 0x62,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x65,
    0x65, 0x65, 0x65, 0x65, 0x66, 0x66, 0x66, 0x66, 0x66, 0x67, 0x67, 0x67,
    0x67, 0x67, 0x67, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x69, 0x69, 0x69,
    0x69, 0x69, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6B, 0x6B, 0x6B, 0x6B,
    0x6B, 0x6B, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6D, 0x6D, 0x6D, 0x6D,
    0x6D, 0x6D, 0x6D, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6F, 0x6F, 0x6F,
    0x6F, 0x6F, 0x6F, 0x6F, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x71,
    0x71, 0x71, 0x71, 0x71, 0x71, 0x71, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72,
    0x72, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x74, 0x74, 0x74,
    0x74, 0x74, 0x74, 0x74, 0x74, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75,
    0x75, 0x75, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x77,
    0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x78, 0x78, 0x78,
    0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x79, 0x79, 0x79, 0x79,
    0x79, 0x79, 0x79, 0x79, 0x79,
};

static const uint8_t needle2_y[LOG_LUT_LEN] = {
    0x2F, 0x2F, 0x26, 0x22, 0x1F, 0x1D, 0x1B, 0x19, 0x18, 0x17, 0x16, 0x15,
    0x14, 0x14, 0x13, 0x12, 0x12, 0x12, 0x11, 0x11, 0x10, 0x10, 0x10, 0x0F,
    0x0F, 0x0F, 0x0F, 0x0E, 0x0E, 0x0E, 0x0E, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
    0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
    0x09, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D,
    0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,
    0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x10,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11,
    0x11, 0x11, 0x11, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x13, 0x13,
    0x13, 0x13, 0x13, 0x13, 0x13, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1D,
    0x1D, 0x1D, 0x1D, 0x1D, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1F, 0x1F,
    0x1F, 0x1F, 0x1F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21, 0x21, 0x21, 0x21,
    0x21, 0x22, 0x22, 0x22, 0x22, 0x22, 0x23, 0x23, 0x23, 0x23, 0x23, 0x24,
    0x24, 0x24, 0x24, 0x24, 0x25, 0x25, 0x25, 0x25, 0x25, 0x26, 0x26, 0x26,
    0x26, 0x26, 0x27, 0x27, 0x27, 0x27, 0x27, 0x28, 0x28, 0x28, 0x28, 0x28,
    0x29, 0x29, 0x29, 0x29, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2B, 0x2B, 0x2B,
    0x2B, 0x2B, 0x2C, 0x2C, 0x2C, 0x2C, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2E,
    0x2E, 0x2E, 0x2E, 0x2F, 0x2F,
};

static const uint8_t ticks1_x[16] = {
    0x0C, 0x0C, 0x12, 0x1B, 0x1F, 0x29, 0x32, 0x39,
    0x45, 0x4C, 0x55, 0x5F, 0x63, 0x6C, 0x72, 0x72,
};

static const uint8_t ticks1_y[16] = {
    0x32, 0x28, 0x1F, 0x1C, 0x14, 0x0E, 0x10, 0x0A,
    0x0A, 0x10, 0x0E, 0x14, 0x1C, 0x1F, 0x28, 0x32,
};

static const uint8_t ticks2_x[16] = {
    0x05, 0x09, 0x0F, 0x16, 0x1D, 0x27, 0x30, 0x39,
    0x45, 0x4E, 0x57, 0x61, 0x68, 0x6F, 0x75, 0x79,
};

static const uint8_t ticks2_y[16] = {
    0x2F, 0x26, 0x1D, 0x16, 0x10, 0x0B, 0x08, 0x06,
    0x06, 0x08, 0x0B, 0x10, 0x16, 0x1D, 0x26, 0x2F,
};

static char const *const tick_labels[6] = {
    "0.01", "0.1", "1", "10", "100", "1000",
};

static u8g2_t u8g2;
static volatile uint_fast16_t g_pulse_count;
static volatile uint_fast8_t g_is_power_save;
static volatile uint_fast8_t g_alarm_level;
static volatile led_state_t g_led_state = {
    .state = false,
    .pulse_timer = 0,
};
static volatile buzzer_state_t g_buzzer_state = {
    .state = false,
};

ISR(TCA0_CMP0_vect) {
  TCA0.SINGLE.INTFLAGS = TCA_SINGLE_CMP0_bm;
  if (AC0.STATUS & AC_STATE_bm) {
    TCA0.SINGLE.CTRLA &= ~TCA_SINGLE_ENABLE_bm;
  }
}

ISR(AC0_AC_vect) {
  TCA0.SINGLE.CTRLA |= TCA_SINGLE_ENABLE_bm;
  AC0.STATUS = AC_CMP_bm;
}

ISR(PORTB_PORT_vect) {
  PORTB.INTFLAGS = GEIGER_PULSE_PIN;
  g_pulse_count++;

  if (!g_led_state.state) {
    if ((!g_is_power_save) || (g_alarm_level != alarm_level_green)) {
      switch (g_alarm_level) {
        case alarm_level_green:
          PORTA.OUTCLR = GREEN_LED_PIN;
          break;

        case alarm_level_orange:
          PORTA.OUTCLR = GREEN_LED_PIN | RED_LED_PIN;
          break;

        case alarm_level_red:
          PORTA.OUTCLR = RED_LED_PIN;
          break;
      }
      g_led_state.pulse_timer = 0;
      g_led_state.state = true;
    }
  }

  if ((g_alarm_level > alarm_level_green) && (!g_buzzer_state.state)) {
    PORTC.OUTSET = BUZZER_PULSE_PIN;
    TCB0.CNT = 0;
    TCB0.CTRLA |= TCB_ENABLE_bm;
    g_buzzer_state.state = true;
  }
}

ISR(RTC_PIT_vect) {
  static uint_fast16_t dose_calc_timeout = 0;
  static button_state_t button_state = {
      .pressed = false,
      .deb_count = 0,
      .press_count = 0,
  };

  RTC.PITINTFLAGS = RTC_PI_bm;

  if (g_led_state.state) {
    g_led_state.pulse_timer++;
    if (g_led_state.pulse_timer == LED_PULSE_TICKS) {
      PORTA.OUTSET = GREEN_LED_PIN | RED_LED_PIN;
      g_led_state.state = false;
    }
  }

  dose_calc_timeout++;
  if (dose_calc_timeout == DOSE_CALC_TIMEOUT_TICKS) {
    dose_calc_timeout = 0;
    g_events |= EV_DOSE_CALC_TIMEOUT;
  }

  if (button_state.pressed) {
    if (PORTA.IN & BUTTON_PIN) {
      button_state.deb_count--;
      if (button_state.deb_count == 0) {
        button_state.pressed = false;
        if (button_state.press_count < 300) {
          g_events |= EV_BUTTON_SHORT_PRESS;
        }
      }
    } else {
      if (button_state.deb_count < BUTTON_DEBOUNCE_COUNT) {
        button_state.deb_count++;
      }
    }
  } else {
    if (!(PORTA.IN & BUTTON_PIN)) {
      button_state.deb_count++;
      if (button_state.deb_count == BUTTON_DEBOUNCE_COUNT) {
        button_state.pressed = true;
        button_state.press_count = 0;
      }
    } else {
      if (button_state.deb_count > 0) {
        button_state.deb_count--;
      }
    }
  }

  if (button_state.pressed == true) {
    if (button_state.press_count < 300) {
      button_state.press_count++;
      if (button_state.press_count == 300) {
        g_events |= EV_BUTTON_LONG_PRESS;
      }
    }
  }
}

ISR(TCB0_INT_vect) {
  TCB0.INTFLAGS = TCB_CAPT_bm;
  if (g_buzzer_state.state) {
    PORTC.OUTCLR = BUZZER_PULSE_PIN;
    TCB0.CTRLA &= ~TCB_ENABLE_bm;
    g_buzzer_state.state = false;
  }
}

static void configure_pins(void) {
  PORTA.DIR = 0;
  PORTA.PIN0CTRL |= PORT_PULLUPEN_bm;
  PORTA.PIN1CTRL |= PORT_PULLUPEN_bm;
  PORTA.PIN2CTRL |= PORT_PULLUPEN_bm;
  PORTA.PIN3CTRL |= PORT_PULLUPEN_bm;
  PORTA.PIN4CTRL |= PORT_PULLUPEN_bm;
  PORTA.PIN5CTRL |= PORT_PULLUPEN_bm;
  PORTA.PIN6CTRL |= PORT_PULLUPEN_bm;
  PORTA.PIN7CTRL |= PORT_PULLUPEN_bm;

  PORTB.DIR = 0;
  PORTB.PIN0CTRL |= PORT_PULLUPEN_bm;
  PORTB.PIN1CTRL |= PORT_PULLUPEN_bm;
  PORTB.PIN2CTRL |= PORT_PULLUPEN_bm;
  PORTB.PIN3CTRL |= PORT_PULLUPEN_bm;
  PORTB.PIN4CTRL |= PORT_PULLUPEN_bm;
  PORTB.PIN5CTRL |= PORT_PULLUPEN_bm;

  PORTC.DIR = 0;
  PORTC.PIN0CTRL |= PORT_PULLUPEN_bm;
  PORTC.PIN1CTRL |= PORT_PULLUPEN_bm;
  PORTC.PIN2CTRL |= PORT_PULLUPEN_bm;
  PORTC.PIN3CTRL |= PORT_PULLUPEN_bm;
}

static inline void configure_pwm(void) {
  // make sure to update this after changing HV_BOOST_PWM_PIN
  PORTMUX.TCAROUTEA = PORTMUX_TCA00_ALT1_gc;
  TCA0.SINGLE.INTCTRL = TCA_SINGLE_CMP0_bm;
  TCA0.SINGLE.CTRLB = TCA_SINGLE_WGMODE_SINGLESLOPE_gc | TCA_SINGLE_CMP0EN_bm;
  TCA0.SINGLE.PER = 1000 - 1;  // 10kHz
  TCA0.SINGLE.CMP0 = (750);    // 75% duty

  // Turn on timer
  TCA0.SINGLE.CTRLA =
      TCA_SINGLE_CLKSEL_DIV1_gc | TCA_SINGLE_RUNSTDBY_bm | TCA_SINGLE_ENABLE_bm;
  PORTB.DIRSET = HV_BOOST_PWM_PIN;
}

static inline void configure_buzzer(void) {
  PORTC.PIN0CTRL &= ~PORT_PULLUPEN_bm;
  PORTC.DIRSET = BUZZER_PULSE_PIN;
  PORTC.OUTCLR = BUZZER_PULSE_PIN;

  TCB0.CTRLB = TCB_CNTMODE_INT_gc;
  TCB0.CCMP = TCB0.CNT = 920 - 1;  // ~185us
  TCB0.INTCTRL = TCB_CAPT_bm;
  TCB0.CTRLA = TCB_CLKSEL_DIV2_gc | TCB_RUNSTDBY_bm;
}

static inline void configure_comparator(void) {
  PORTA.PIN7CTRL = PORT_ISC_INPUT_DISABLE_gc;

  VREF.CTRLA = VREF_AC0REFSEL_1V024_gc;

  AC0.DACREF = DACREF_VALUE;

  AC0.INTCTRL = AC_CMP_bm;

  AC0.MUXCTRLA = AC_MUXPOS_AINP0_gc | AC_MUXNEG_DACREF_gc;
  AC0.CTRLA = AC_ENABLE_bm | AC_HYSMODE_50mV_gc | AC_RUNSTDBY_bm |
              AC_LPMODE_EN_gc | AC_INTMODE_NEGEDGE_gc;
}

static inline void configure_adc(void) {
  ADC0.CTRLA = ADC_ENABLE_bm;
  ADC0.CTRLB = ADC_PRESC_DIV4_gc;
  ADC0.CTRLC = ADC_REFSEL_1024MV_gc | (5 << ADC_TIMEBASE_gp);
  ADC0.CTRLE = 160;  // 64us

  ADC0.COMMAND = ADC_MODE_SINGLE_12BIT_gc;
}

static inline void configure_geiger_pulse_input(void) {
  PORTB.DIRCLR = GEIGER_PULSE_PIN;
  PORTB.PIN2CTRL = PORT_ISC_FALLING_gc;  // needs to be "fully asynchronous" to
                                         // wake from standby (PINx2, or PINx6)
}

static inline void configure_rtc(void) {
  while (RTC.STATUS > 0) {
    ; /* Wait for all register to be synchronized */
  }

  RTC.CLKSEL = RTC_CLKSEL_INT32K_gc;
  RTC.PITINTCTRL = RTC_PI_bm;
  RTC.PITCTRLA = RTC_PERIOD_CYC32_gc | RTC_PITEN_bm;
}

static inline void configure_leds(void) {
  PORTA.DIRSET = GREEN_LED_PIN | RED_LED_PIN;
  PORTA.OUTSET = GREEN_LED_PIN | RED_LED_PIN;
}

static inline void configure_button(void) {
  PORTA.DIRCLR = BUTTON_PIN;           // input
  PORTA.PIN1CTRL |= PORT_PULLUPEN_bm;  // with pullup
}

static inline void configure_watchdog(void) {
  _PROTECTED_WRITE(WDT.CTRLA, WDT_PERIOD_1KCLK_gc);
  while (WDT.STATUS & WDT_SYNCBUSY_bm) {
    ;
  }
}

static inline uint16_t read_vdd(void) {
  ADC0.MUXPOS = ADC_MUXPOS_VDDDIV10_gc;
  ADC0.COMMAND |= ADC_START_IMMEDIATE_gc;

  while (ADC0.STATUS & ADC_ADCBUSY_bm) {
    ;
  }

  return ADC0.SAMPLE / 4;  // in tens of mV
}

static inline int16_t read_temp(void) {
  ADC0.MUXPOS = ADC_MUXPOS_TEMPSENSE_gc;
  ADC0.COMMAND |= ADC_START_IMMEDIATE_gc;

  while (ADC0.STATUS & ADC_ADCBUSY_bm) {
    ;
  }

  const int8_t sigrow_offset = SIGROW.TEMPSENSE1;
  const uint8_t sigrow_gain = SIGROW.TEMPSENSE0;
  const uint16_t adc_reading = ADC0.RESULT >> 2;
  uint32_t temp = adc_reading - sigrow_offset;
  temp *= sigrow_gain;
  temp += 0x80;
  temp >>= 8;
  uint16_t temperature_in_K = temp;

  return ((int16_t)temperature_in_K * 10) - 2732;
}

static void eeprom_write_word_at(uint16_t word, uint16_t pos) {
  *(uint16_t *)(EEPROM_START + pos) = word;
  while (NVMCTRL.STATUS & NVMCTRL_EEBUSY_bm) {
    ;
  }
  _PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, NVMCTRL_CMD_PAGEERASEWRITE_gc);
}

static void out_of_range(void) {
  u8g2_SetFont(&u8g2, BIG_LABEL_FONT);
  uint8_t w = u8g2_GetStrWidth(&u8g2, "Out of range!");
  u8g2_DrawStr(&u8g2, (128 - w) / 2, 32, "Out of range!");
}

static uint8_t get_rate_value_str(char *const str, uint8_t size,
                                  uint32_t rate) {
  uint8_t len;
  if (rate < 100000) {
  } else if (rate < 100000000) {
    rate /= 1000;
  }

  if (rate < 100000) {
    len = snprintf(str, size, "%ld.%02ld", rate / 100, rate % 100);
  } else {
    len = snprintf(str, size, "......");
  }

  return len;
}

static uint8_t get_rate_unit_str(char *const str, uint8_t size, uint32_t rate,
                                 bool unicode) {
  uint8_t len;

  if (rate < 100000) {
    if (unicode) {
      len = snprintf(str, size, "\xb5Sv/h");
    } else {
      len = snprintf(str, size, "uSv/h");
    }
  } else if (rate < 100000000) {
    len = snprintf(str, size, "mSv/h");
  } else {
    len = snprintf(str, size, "???");
  }

  return len;
}

static uint16_t get_log_rate(uint32_t rate, uint16_t *idx) {
  uint32_t prev_log_x = 0;

  for (size_t i = 0; i < sizeof(logy) / sizeof(logy[0]); i++) {
    uint32_t log_x = logx[i];
    if (i > LOG_EXT_IDX) {
      log_x += 0x10000;
    }
    if (log_x > rate) {
      const size_t j = (log_x - rate) <= (rate - prev_log_x) ? i : i - 1;
      if (idx) {
        *idx = j;
      }
      return logy[j];
    }
    prev_log_x = log_x;
  }
  if (idx) {
    *idx = LOG_LUT_LEN - 1;
  }
  return logy[LOG_LUT_LEN - 1];
}

static void draw_rate_history(uint32_t const *const data, uint16_t data_len,
                              uint16_t start_idx, uint32_t *rate_min,
                              uint32_t *rate_max) {
  uint16_t idx = start_idx;
  uint32_t _rate_max = data[idx];
  uint32_t _rate_min = data[idx];

  // find max and min rate
  while (true) {
    const uint32_t rate = data[idx];
    if (rate > _rate_max) {
      _rate_max = rate;
    }
    if (rate < _rate_min) {
      _rate_min = rate;
    }

    idx = (idx + 1) % data_len;
    if (idx == start_idx) {
      break;
    }
  }

  *rate_min = _rate_min;
  *rate_max = _rate_max;

  // adjust min and max to the closest logarithmic scale
  {
    uint32_t s = 1;
    while (_rate_max > s) {
      s *= 10;
    }
    _rate_max = s;

    s = 1;
    while (_rate_min >= s) {
      s *= 10;
    }
    if (s >= 10) {
      s /= 10;
    } else {
      s = 0;
    }
    _rate_min = s;
  }

  const uint16_t range =
      get_log_rate(_rate_max, NULL) - get_log_rate(_rate_min, NULL);
  idx = start_idx;
  uint16_t i = 0;

  uint8_t y_prev = 0;
  uint8_t y_prev2 = 0;

  while (true) {
    const uint16_t rate =
        get_log_rate(data[idx], NULL) - get_log_rate(_rate_min, NULL);
    uint32_t y = 60 - 32;

    if (range > 0) {
      y = rate * 46 / range;
    }

    if (i == 0) {
      y_prev = y;
      y_prev2 = y;
    }

    // fill area under the graph
    for (uint8_t j = 0; j < y; j++) {
      if ((j % 2) == (i % 2)) {
        u8g2_DrawPixel(&u8g2, 4 + i, 60 - j);
      }
    }

    if ((y >= y_prev) && (y <= y_prev2)) {
      u8g2_DrawPixel(&u8g2, 4 + i, 60 - y);
      y_prev2 = y_prev = y;
    } else {
      if (y > y_prev2) {
        u8g2_DrawVLine(&u8g2, 4 + i, 60 - y, y - y_prev2 + 1);
        y_prev = y_prev2;
        y_prev2 = y;
      } else {
        u8g2_DrawVLine(&u8g2, 4 + i, 60 - y_prev, y_prev - y + 1);
        y_prev2 = y_prev;
        y_prev = y;
      }
    }

    idx = (idx + 1) % data_len;
    if (idx == start_idx) {
      break;
    }
    i++;
  }
}

static void draw_analog_dial(uint32_t rate) {
  uint8_t w;
  char tmp[8];

  u8g2_SetFont(&u8g2, MEDIUM_LABEL_FONT);
  for (size_t i = 0; i < sizeof(ticks1_x); i++) {
    u8g2_DrawLine(&u8g2, ticks1_x[i], ticks1_y[i], ticks2_x[i], ticks2_y[i]);
  }

  for (size_t i = 1; i < (sizeof(tick_labels) / sizeof(tick_labels[0])) - 1;
       i++) {
    w = u8g2_GetStrWidth(&u8g2, tick_labels[i]);
    u8g2_DrawStr(&u8g2, ticks2_x[3 * i] - (w / 2) + (i > 2 ? 3 : -3),
                 ticks2_y[3 * i] - 2, tick_labels[i]);
  }

  u8g2_DrawStr(&u8g2, 1, 63, tick_labels[0]);
  u8g2_DrawStr(&u8g2, 105, 63, tick_labels[5]);

  uint16_t log_rate_idx;
  get_log_rate(rate, &log_rate_idx);
  u8g2_DrawLine(&u8g2, needle1_x[log_rate_idx], needle1_y[log_rate_idx],
                needle2_x[log_rate_idx], needle2_y[log_rate_idx]);

  u8g2_SetDrawColor(&u8g2, 0);
  u8g2_DrawDisc(&u8g2, 64, 74, 30, U8G2_DRAW_ALL);
  u8g2_SetDrawColor(&u8g2, 1);
  u8g2_DrawArc(&u8g2, 64, 74, 30, 0, 128);

  // Due to inaccuracies in the arc drawing
  // the angles need corrections to look good
  u8g2_DrawArc(&u8g2, 64, 74, 52, MAX_RATE_THRESHOLD_ANGLE + 3,
               ORANGE_THRESHOLD_ANGLE - 1);
  u8g2_DrawArc(&u8g2, 64, 74, 52 - 3, MAX_RATE_THRESHOLD_ANGLE + 3,
               RED_THRESHOLD_ANGLE + 2);

  u8g2_SetFont(&u8g2, BIG_LABEL_FONT);
  get_rate_unit_str(tmp, sizeof(tmp), rate, true);
  w = u8g2_GetStrWidth(&u8g2, tmp);
  u8g2_DrawStr(&u8g2, (128 - w) / 2, 61, tmp);
}

static void draw_rate_bar(uint32_t rate) {
  uint16_t log_rate;
  const uint32_t ticks[] = {1,   2,    5,    10,   20,    50,    100,   200,
                            500, 1000, 2000, 5000, 10000, 20000, 50000, 100000};

  for (size_t i = 0; i < (sizeof(ticks) / sizeof(ticks[0])); i++) {
    log_rate = get_log_rate(ticks[i], NULL);
    log_rate = (log_rate / 10) + (9 * log_rate / 100);
    if ((ticks[i] == ORANGE_THRESHOLD) || (ticks[i] == RED_THRESHOLD)) {
      u8g2_DrawVLine(&u8g2, 3 + log_rate, 57, (i % 3) == 0 ? 5 : 3);
    } else {
      u8g2_DrawVLine(&u8g2, 3 + log_rate, 58, (i % 3) == 0 ? 5 : 3);
    }
  }

  u8g2_DrawHLine(&u8g2, 3, 58, 122);
  log_rate = get_log_rate(rate, NULL);
  log_rate = (log_rate / 10) + (9 * log_rate / 100);
  u8g2_DrawTriangle(&u8g2, log_rate, 63, 3 + log_rate, 58, 6 + log_rate, 63);
}

static void update_display(display_ctx_t *ctx) {
  char tmp[32];
  uint8_t w;

  if (ctx->state != display_power_save) {
    u8g2_ClearBuffer(&u8g2);
  }

  switch (ctx->state) {
    case display_rate:
      u8g2_SetFont(&u8g2, BIG_LABEL_FONT);
      get_rate_unit_str(tmp, sizeof(tmp), ctx->rate, true);
      u8g2_DrawStr(&u8g2, 90, 10, tmp);

      u8g2_SetFont(&u8g2, main_font);
      get_rate_value_str(tmp, sizeof(tmp), ctx->rate);
      w = u8g2_GetStrWidth(&u8g2, tmp);
      u8g2_DrawStr(&u8g2, 127 - w, DIGITS_Y_POS, tmp);
      break;

    case display_rate_analog:
      draw_analog_dial(ctx->rate);
      break;

    case display_cpm:
      if (ctx->cpm < 1000) {
        snprintf(tmp, sizeof(tmp), "%ld", ctx->cpm);
        u8g2_SetFont(&u8g2, main_font);
        w = u8g2_GetStrWidth(&u8g2, tmp);
        u8g2_DrawStr(&u8g2, 127 - w, DIGITS_Y_POS, tmp);
        u8g2_SetFont(&u8g2, BIG_LABEL_FONT);
        u8g2_DrawStr(&u8g2, 90, 10, "CPM");

      } else {
        ctx->cpm /= 10;
        snprintf(tmp, sizeof(tmp), "%ld.%02ld", ctx->cpm / 100, ctx->cpm % 100);
        u8g2_SetFont(&u8g2, main_font);
        w = u8g2_GetStrWidth(&u8g2, tmp);
        u8g2_DrawStr(&u8g2, 127 - w, DIGITS_Y_POS, tmp);

        u8g2_SetFont(&u8g2, BIG_LABEL_FONT);
        u8g2_DrawStr(&u8g2, 90, 10, "kCPM");
      }
      break;

    case display_dose:
      uint32_t dose = ctx->dose;

      if (dose < 100000) {
        u8g2_SetFont(&u8g2, BIG_LABEL_FONT);
        u8g2_DrawStr(&u8g2, 90, 10, "\xb5Sv");
      } else if (dose < 100000000) {
        dose /= 1000;
        u8g2_SetFont(&u8g2, BIG_LABEL_FONT);
        u8g2_DrawStr(&u8g2, 90, 10, "mSv");
      } else {
        out_of_range();
      }

      if (dose < 100000) {
        snprintf(tmp, sizeof(tmp), "%ld.%02d", dose / 100,
                 (uint8_t)(dose % 100));
        u8g2_SetFont(&u8g2, main_font);
        w = u8g2_GetStrWidth(&u8g2, tmp);
        u8g2_DrawStr(&u8g2, 127 - w, DIGITS_Y_POS, tmp);
      }
      break;

    case display_rate_history:
      uint32_t rate_min, rate_max;
      draw_rate_history(ctx->rate_history, RATE_HISTORY_LEN,
                        ctx->rate_history_idx, &rate_min, &rate_max);
      u8g2_SetFont(&u8g2, BIG_LABEL_FONT);
      u8g2_DrawStr(&u8g2, 90, 10, "10min");

      u8g2_SetFont(&u8g2, SMALL_LABEL_FONT);

      char vs[6];
      char us[6];
      get_rate_value_str(vs, sizeof(vs), rate_max);
      get_rate_unit_str(us, sizeof(us), rate_max, false);

      snprintf(tmp, sizeof(tmp), "%s %s", vs, us);

      w = u8g2_GetStrWidth(&u8g2, tmp);
      u8g2_SetDrawColor(&u8g2, 0);
      u8g2_DrawBox(&u8g2, 3, 17, w + 5, 10);
      u8g2_SetDrawColor(&u8g2, 1);
      u8g2_DrawFrame(&u8g2, 3, 17, w + 5, 10);
      u8g2_DrawStr(&u8g2, 5, 25, tmp);

      get_rate_value_str(vs, sizeof(vs), rate_min);
      get_rate_unit_str(us, sizeof(us), rate_min, false);

      snprintf(tmp, sizeof(tmp), "%s %s", vs, us);

      w = u8g2_GetStrWidth(&u8g2, tmp);
      u8g2_SetDrawColor(&u8g2, 0);
      u8g2_DrawBox(&u8g2, 3, 47, w + 5, 10);
      u8g2_SetDrawColor(&u8g2, 1);
      u8g2_DrawFrame(&u8g2, 3, 47, w + 5, 10);
      u8g2_DrawStr(&u8g2, 5, 55, tmp);
      break;

    case display_state_info:
      u8g2_SetFont(&u8g2, MEDIUM_LABEL_FONT);

      uint32_t c = 5 * ctx->uptime_counter;  // s
      const uint16_t days = c / (24UL * 3600);
      c %= (24UL * 3600);
      const uint8_t hours = c / 3600;
      c %= 3600;
      const uint8_t minutes = c / 60;
      c %= 60;
      const uint8_t seconds = c;
      snprintf(tmp, sizeof(tmp), "Uptime: %dd %dh %dm %ds", days, hours,
               minutes, seconds);
      u8g2_DrawStr(&u8g2, 3, 10, tmp);

      dose = ctx->dose;
      if (dose < 100000) {
        snprintf(tmp, sizeof(tmp), "Dose: %ld.%02d uSv", dose / 100,
                 (uint8_t)(dose % 100));
      } else if (dose < 100000000) {
        dose /= 1000;
        snprintf(tmp, sizeof(tmp), "Dose: %ld.%02d mSv", dose / 100,
                 (uint8_t)(dose % 100));
      } else {
        dose /= 1000000;
        snprintf(tmp, sizeof(tmp), "Dose: %ld.%02d Sv", dose / 100,
                 (uint8_t)(dose % 100));
      }
      u8g2_DrawStr(&u8g2, 3, 20, tmp);

      snprintf(tmp, sizeof(tmp), "Voltage: %d.%02dV", ctx->vdd / 100,
               ctx->vdd % 100);
      u8g2_DrawStr(&u8g2, 3, 30, tmp);

      snprintf(tmp, sizeof(tmp), "Temperature: %d.%dC", ctx->temp / 10,
               abs(ctx->temp) % 10);
      u8g2_DrawStr(&u8g2, 3, 40, tmp);

      snprintf(tmp, sizeof(tmp), "Resets: %d", ctx->reset_counter);
      u8g2_DrawStr(&u8g2, 3, 50, tmp);

      break;
  }

  if (ctx->state != display_power_save) {
    if (!((ctx->state == display_state_info) ||
          (ctx->state == display_rate_analog))) {
      if (ctx->alarm_level > alarm_level_green) {
        u8g2_DrawXBM(&u8g2, 5, 0, warning_width, warning_height, warning_bits);
      }
      if (ctx->alarm_level > alarm_level_orange) {
        u8g2_DrawXBM(&u8g2, 22, 0, warning_width, warning_height, warning_bits);
      }
    }

    if ((ctx->state != display_state_info)) {
      u8g2_SetFont(&u8g2, icons_font);
      if (ctx->state == display_rate_analog) {
        u8g2_DrawGlyph(&u8g2, 5, 20, '0' + ctx->bat_level);
      } else {
        u8g2_DrawGlyph(&u8g2, 60, 20, '0' + ctx->bat_level);
      }
      if (!((ctx->state == display_rate_analog) ||
            (ctx->state == display_rate_history))) {
        draw_rate_bar(ctx->rate);
      }
    }

    u8g2_SendBuffer(&u8g2);
  }
}

int main(void) {
  uint16_t cpm_buf[CPM_BUF_SIZE] = {0};
  uint8_t cpm_i = 0;
  static display_ctx_t display_ctx = {
      .state = display_power_save,
      .timeout = DISPLAY_TIMEOUT_COUNT,
      .cpm = 0,
      .rate = 0,
      .dose = 0,
      .alarm_level = alarm_level_green,
      .vdd = 0,
      .bat_level = 0,
      .temp = 0,
      .rate_history_idx = 0,
      .uptime_counter = 0,
      .reset_counter = 0,
  };
  uint16_t dose_pulses = 0;
  uint8_t last_disp_state = display_rate;

  // 20MHz / 2 = 10MHz clock
  _PROTECTED_WRITE(CLKCTRL.MCLKCTRLB, CLKCTRL_PDIV_2X_gc | CLKCTRL_PEN_bm);
  _PROTECTED_WRITE(CLKCTRL.OSC20MCTRLA, CLKCTRL_RUNSTDBY_bp);

  power_all_disable();
  configure_pins();
  configure_button();
  configure_leds();
  configure_buzzer();
  configure_geiger_pulse_input();

  if (RSTCTRL.RSTFR & RSTCTRL_PORF_bm) {
    eeprom_write_word_at(0, 0);
  } else {
    uint16_t v = *(uint16_t *)(EEPROM_START);
    eeprom_write_word_at(v + 1, 0);
  }

  display_ctx.reset_counter = *(uint16_t *)(EEPROM_START);

  configure_comparator();
  configure_pwm();
  configure_rtc();
  configure_adc();

  u8g2_Setup_sh1106_i2c_128x64_noname_f(&u8g2, U8G2_R0, u8x8_byte_avr_hw_i2c,
                                        u8x8_avr_delay);
  u8g2_SetI2CAddress(&u8g2, DISPLAY_I2C_ADDR >> 1);
  u8g2_InitDisplay(&u8g2);
  u8g2_SetPowerSave(&u8g2, 0);
  u8g2_SetContrast(&u8g2, 128);
  // u8g2_SetFlipMode(&u8g2, 1);

  {
    // title screen
    u8g2_ClearDisplay(&u8g2);
    u8g2_DrawRFrame(&u8g2, 1, 1, 126, 62, 4);
    u8g2_SetFont(&u8g2, icons_font);
    uint8_t w = u8g2_GetGlyphWidth(&u8g2, '0' + 5);
    u8g2_DrawGlyph(&u8g2, 6, 28, '0' + 5);
    u8g2_DrawGlyph(&u8g2, 128 - w - 6, 28, '0' + 5);
    w = u8g2_GetGlyphWidth(&u8g2, '0' + 6);
    u8g2_DrawGlyph(&u8g2, (128 - w) / 2, 28, '0' + 6);

    u8g2_SetFont(&u8g2, BIG_LABEL_FONT);
    w = u8g2_GetStrWidth(&u8g2, "ATtiny");
    u8g2_DrawStr(&u8g2, (128 - w) / 2, 35, "ATtiny");
    w = u8g2_GetStrWidth(&u8g2, "Geiger counter");
    u8g2_DrawStr(&u8g2, (128 - w) / 2, 46, "Geiger counter");
    u8g2_SetFont(&u8g2, SMALL_LABEL_FONT);
    u8g2_DrawStr(&u8g2, 5, 59, "ver: " COMMIT_ID);
    u8g2_SendBuffer(&u8g2);
    _delay_ms(5000);
    u8g2_ClearDisplay(&u8g2);
  }

  u8g2_SetPowerSave(&u8g2, 1);

  set_sleep_mode(SLEEP_MODE_STANDBY);

  configure_watchdog();

  while (true) {
    cli();
    g_is_power_save = display_ctx.state == display_power_save;
    g_alarm_level = display_ctx.alarm_level;
    while (!g_events) {
      sleep_enable();
      sei();
      sleep_cpu();
      sleep_disable();
      wdt_reset();
      cli();
    }
    events = g_events;
    g_events = 0;
    sei();

    if (events & (EV_BUTTON_SHORT_PRESS | EV_BUTTON_LONG_PRESS)) {
      display_ctx.timeout = DISPLAY_TIMEOUT_COUNT;

      switch (display_ctx.state) {
        case display_power_save:
          u8g2_SetPowerSave(&u8g2, 0);
          display_ctx.vdd = read_vdd();
          display_ctx.temp = read_temp();

          display_ctx.bat_level = BATTERY_LEVEL_NUM;
          for (int i = 0; i < BATTERY_LEVEL_NUM; i++) {
            if (display_ctx.vdd <
                (battery_level_thresholds[i] * NUM_BATTERIES)) {
              display_ctx.bat_level = i;
              break;
            }
          }

          if (events & EV_BUTTON_SHORT_PRESS) {
            display_ctx.state = last_disp_state;
          } else {
            display_ctx.state = display_state_info;
          }
          break;

        case display_rate:
        case display_rate_analog:
        case display_cpm:
        case display_dose:
        case display_rate_history:
          if (events & EV_BUTTON_SHORT_PRESS) {
            display_ctx.state++;
            if (display_ctx.state == display_state_loop) {
              display_ctx.state = display_rate;
            }
          } else if (events & EV_BUTTON_LONG_PRESS) {
            last_disp_state = display_ctx.state;
            display_ctx.state = display_state_info;
          }
          break;

        case display_state_info:
          if (events & EV_BUTTON_LONG_PRESS) {
            display_ctx.state = last_disp_state;
          }
          break;
      }

      if (!(events & EV_DOSE_CALC_TIMEOUT)) {
        update_display(&display_ctx);
      }
    }

    if (events & EV_DOSE_CALC_TIMEOUT) {
      display_ctx.uptime_counter++;

      uint_fast16_t pc5s;
      ATOMIC_BLOCK(ATOMIC_FORCEON) {
        pc5s = g_pulse_count;
        g_pulse_count = 0;
      }

      // dead time correction
      uint_fast16_t pc5s_dtc;
      if (pc5s <= 1500) {
        pc5s_dtc = pc5s / 6;
        pc5s_dtc *= pc5s_dtc;
        pc5s_dtc /= 689;
        pc5s_dtc += pc5s;
      } else {
        const uint_fast16_t a = pc5s + 7;
        uint_fast16_t b = a / 28;
        b *= b;
        b /= 35;
        uint_fast16_t c = a / 256;
        c *= b;
        c /= 64;
        pc5s_dtc = a + b + c;
      }

      dose_pulses += pc5s_dtc;
      display_ctx.dose += dose_pulses / 92;  // 92 here is from assumed k=0.0065
                                             // (first two digits from 60 / k)
      dose_pulses %= 92;

      // 1-minute rolling sum
      display_ctx.cpm -= cpm_buf[cpm_i];
      display_ctx.cpm += pc5s_dtc;
      cpm_buf[cpm_i] = pc5s_dtc;
      ++cpm_i;
      if (cpm_i == CPM_BUF_SIZE) {
        cpm_i = 0;
      }

      // dose_rate in 0.01 µSv/hr

      // this calculation is for SBM-20 tube,
      // with conversion factor of k = 0.0065
      display_ctx.rate = display_ctx.cpm >> 1;
      display_ctx.rate += (3 * display_ctx.rate) / 10;

      display_ctx.rate_history[display_ctx.rate_history_idx++] =
          display_ctx.rate;

      if (display_ctx.rate_history_idx == RATE_HISTORY_LEN) {
        display_ctx.rate_history_idx = 0;
      }

      // // this calculation is for SBM-20 tube,
      // // with conversion factor of k = 0.0052
      // dose = cpm >> 1;
      // dose += dose / 25;

      // this calculation is for J305 tube,
      // (some sources seem to indicate
      // that this is in fact also the correct
      // value for SBM-20 tube)
      // with conversion factor of k = 0.00812
      // dose = cpm >> 1;
      // dose += (dose >> 1) + (dose >> 3);

      if (display_ctx.rate < ORANGE_THRESHOLD) {
        display_ctx.alarm_level = alarm_level_green;
      } else if (display_ctx.rate < RED_THRESHOLD) {
        display_ctx.alarm_level = alarm_level_orange;
      } else {
        display_ctx.alarm_level = alarm_level_red;
      }

      if (display_ctx.state != display_power_save) {
        if (display_ctx.timeout > 0) {
          display_ctx.timeout--;
          if (display_ctx.timeout == 0) {
            u8g2_ClearDisplay(&u8g2);
            u8g2_SetPowerSave(&u8g2, 1);
            if (display_ctx.state != display_state_info) {
              last_disp_state = display_ctx.state;
            }
            display_ctx.state = display_power_save;
          } else {
            if (display_ctx.state == display_state_info) {
              u8g2_SetPowerSave(&u8g2, 0);
              display_ctx.vdd = read_vdd();
              display_ctx.temp = read_temp();
            }
          }
        }
      }

      if (display_ctx.state != display_power_save) {
        update_display(&display_ctx);
      }
    }
  }
}
